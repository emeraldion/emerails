#!/usr/bin/env php
<?php
/**
 *                                   _ __
 *   ___  ____ ___  ___  _________ _(_) /____
 *  / _ \/ __ `__ \/ _ \/ ___/ __ `/ / / ___/
 * /  __/ / / / / /  __/ /  / /_/ / / (__  )
 * \___/_/ /_/ /_/\___/_/   \__,_/_/_/____/
 *
 * (c) Claudio Procida 2008-2023
 *
 * @format
 */

require_once __DIR__ . '/base.php';

use splitbrain\phpcli\Options;

use Emeraldion\EmeRails\Helpers\ANSIColorWriter;

class EmerailsLocalize extends ScriptCommand
{
    protected $name = 'EmeRails Localization Utility';
    protected $version = 'v1.0';

    const DEFAULT_BASE_DIR = '/../../assets/strings';
    const STRINGS_FILE_EXTENSION = '.strings';

    const COMMAND_CHECK = 'check';
    const COMMAND_CREATE = 'create';
    const COMMAND_EXTRACT = 'extract';
    const COMMAND_FORMAT = 'format';

    const OPTION_BASE_DIR = 'base-dir';
    const OPTION_CONTROLLER = 'controller';
    const OPTION_DRY_RUN = 'dry-run';
    const OPTION_GLOBAL = 'global';
    const OPTION_LANGUAGES = 'languages';
    const OPTION_PURGE = 'purge';
    const OPTION_RECURSIVE = 'recursive';
    const OPTION_STRICT = 'strict';
    const OPTION_VERBOSE = 'verbose';

    const DEFAULT_LANGUAGE = 'en';

    private $thesaurus = array();

    protected function setup(Options $options)
    {
        $options->setHelp('EmeRails script to manage localization resources');

        // General options
        $options->registerOption(self::OPTION_DRY_RUN, 'Do not save anything');
        $options->registerOption(self::OPTION_VERBOSE, 'Print additional information', 'v');
        $options->registerOption(self::OPTION_BASE_DIR, 'Base directory of strings files', 'd', 'base-dir');

        // Check command
        $options->registerCommand(self::COMMAND_CHECK, 'Check localizations');
        // Check options
        $options->registerOption(
            self::OPTION_RECURSIVE,
            'Recursively descend into subdirectories',
            'r',
            false,
            self::COMMAND_CHECK
        );
        $options->registerOption(self::OPTION_STRICT, 'Fail in presence of warnings', null, false, self::COMMAND_CHECK);

        // Extract command
        $options->registerCommand(self::COMMAND_EXTRACT, 'Extract localization keys from source');
        // Extract options
        $options->registerOption(self::OPTION_PURGE, 'Purges unused strings', 'P', false, self::COMMAND_EXTRACT);

        // Format command
        $options->registerCommand(self::COMMAND_FORMAT, 'Formats localization files');
        // Format options
        $options->registerOption(
            self::OPTION_RECURSIVE,
            'Recursively descend into subdirectories',
            'r',
            false,
            self::COMMAND_FORMAT
        );

        // Create command
        $options->registerCommand(self::COMMAND_CREATE, 'Create localizations');
        // Create options
        $options->registerOption(
            self::OPTION_GLOBAL,
            sprintf(
                'Create global localizations. When provided, the %s option will be ignored.',
                ANSIColorWriter::colorize(sprintf('--%s', self::OPTION_CONTROLLER), 'cyan')
            ),
            'g',
            false,
            self::COMMAND_CREATE
        );
        $options->registerOption(
            self::OPTION_CONTROLLER,
            'Create localizations for a controller',
            'c',
            'controller',
            self::COMMAND_CREATE
        );
        $options->registerOption(
            self::OPTION_LANGUAGES,
            'Comma-separated list of languages for localizations',
            'l',
            'languages',
            self::COMMAND_CREATE
        );
    }

    protected function check(Options $options)
    {
        $dry_run = $options->getOpt(self::OPTION_DRY_RUN);
        $verbose = $options->getOpt(self::OPTION_VERBOSE);
        // This path is relative to the Composer bin directory if available
        $base_dir =
            $options->getOpt(self::OPTION_BASE_DIR) ?:
            ($GLOBALS['_composer_bin_dir'] ?? __DIR__ . '/../vendor/bin') . self::DEFAULT_BASE_DIR;

        unset($this->thesaurus);

        if (!(file_exists($base_dir) && is_dir($base_dir))) {
            printf("No such directory: %s.\n", $base_dir);
            ANSIColorWriter::printf("\n%s\n", 'green', ANSIColorWriter::bold('Done'));
            exit(0);
        }

        if (
            $this->check_dir($base_dir, $options->getOpt(self::OPTION_RECURSIVE), $options->getOpt(self::OPTION_STRICT))
        ) {
            print "All strings files correctly formed.\n";
            ANSIColorWriter::printf("\n%s\n", 'green', ANSIColorWriter::bold('Done'));
        } else {
            ANSIColorWriter::printf("\n%s\n", 'red', ANSIColorWriter::bold('Failure'));
            exit(1);
        }
    }

    protected function create(Options $options)
    {
        $dry_run = $options->getOpt(self::OPTION_DRY_RUN);
        $verbose = $options->getOpt(self::OPTION_VERBOSE);
        // This path is relative to the Composer bin directory if available
        $base_dir =
            $options->getOpt(self::OPTION_BASE_DIR) ?:
            ($GLOBALS['_composer_bin_dir'] ?? __DIR__ . '/../vendor/bin') . self::DEFAULT_BASE_DIR;

        if ($options->getOpt(self::OPTION_GLOBAL)) {
            $dir = $base_dir;
        } else {
            $controller = $options->getOpt(self::OPTION_CONTROLLER);
            $dir = $base_dir . '/' . $controller;
        }
        echo "\tcreating localizations under $dir\n";

        $template = <<<EOT
array(
    // Add your keys below:
    // 'key-of-your-string' => 'This is the user visible text',
);

EOT;

        if (!(file_exists($dir) && is_dir($dir))) {
            if (!mkdir($dir, 0755, true)) {
                exit(1);
            }
        }
        foreach (explode(',', $options->getOpt(self::OPTION_LANGUAGES)) as $language) {
            file_put_contents(sprintf('%s/localizable-%s.strings', $dir, $language), $template);
        }
    }

    protected function format_dir($dir, $write = false, $recursive = false)
    {
        $success = true;

        if (!(file_exists($dir) && is_dir($dir))) {
            return false;
        }
        $handle = opendir($dir);
        if ($handle) {
            while (($filename = readdir($handle)) !== false) {
                if ($filename === '.' || $filename === '..') {
                    continue;
                }
                $path = $dir . '/' . $filename;
                if ($recursive && is_dir($path)) {
                    $success = $success && $this->format_dir($path, $write, $recursive);
                }
                if (str_ends_with($filename, self::STRINGS_FILE_EXTENSION)) {
                    $success = $success && $this->format_file($dir, $filename, $write);
                }
            }
        }

        return $success;
    }

    protected function format(Options $options)
    {
        $dry_run = $options->getOpt(self::OPTION_DRY_RUN);
        $verbose = $options->getOpt(self::OPTION_VERBOSE);
        // This path is relative to the Composer bin directory if available
        $base_dir =
            $options->getOpt(self::OPTION_BASE_DIR) ?:
            ($GLOBALS['_composer_bin_dir'] ?? __DIR__ . '/../vendor/bin') . self::DEFAULT_BASE_DIR;

        if (!(file_exists($base_dir) && is_dir($base_dir))) {
            printf("No such directory: %s.\n", $base_dir);
            ANSIColorWriter::printf("\n%s\n", 'green', ANSIColorWriter::bold('Done'));
            exit(0);
        }

        if ($this->format_dir($base_dir, !$dry_run, $options->getOpt(self::OPTION_RECURSIVE))) {
            print "All strings files correctly formatted.\n";
            ANSIColorWriter::printf("\n%s\n", 'green', ANSIColorWriter::bold('Done'));
        } else {
            ANSIColorWriter::printf("\n%s\n", 'red', ANSIColorWriter::bold('Failure'));
            exit(1);
        }
    }

    /**
     * @fn export_strings($str)
     * @short Slightly better var_export for strings with control on quotes and escape sequences
     */
    protected function export_string($str)
    {
        $has_newlines = strpos($str, "\n") !== false;
        $has_quotes = strpos($str, "'") !== false;

        $ret = addcslashes(var_export($str, true), "\n");

        if ($has_newlines || $has_quotes) {
            $ret = '"' . substr($ret, 1, strlen($ret) - 2) . '"';
            if ($has_quotes) {
                $ret = str_replace("\\'", "'", $ret);
            }
        }

        return $ret;
    }

    protected function main(Options $options)
    {
        switch ($options->getCmd()) {
            case self::COMMAND_CHECK:
                $this->check($options);
                break;
            case self::COMMAND_CREATE:
                $this->create($options);
                break;
            case self::COMMAND_FORMAT:
                $this->format($options);
                break;
            default:
                $options->useCompactHelp();
                print $options->help();
        }
    }

    protected function check_dir($dir, $recursive = false, $strict = false)
    {
        $success = true;

        if (!(file_exists($dir) && is_dir($dir))) {
            return false;
        }
        $handle = opendir($dir);
        if ($handle) {
            while (($filename = readdir($handle)) !== false) {
                if ($filename === '.' || $filename === '..') {
                    continue;
                }
                $path = $dir . '/' . $filename;
                if ($recursive && is_dir($path)) {
                    $success = $success && $this->check_dir($path, $recursive, $strict);
                }
                if (str_ends_with($filename, self::STRINGS_FILE_EXTENSION)) {
                    $success = $success && $this->check_file($dir, $filename);
                }
            }
        }

        $dir = $this->get_string_file($dir);
        if (isset($this->thesaurus[$dir])) {
            foreach ($this->thesaurus[$dir] as $language => $strings) {
                if ($language == self::DEFAULT_LANGUAGE) {
                    continue;
                }
                $common_strings = array_intersect_key(
                    $this->thesaurus[$dir][self::DEFAULT_LANGUAGE] ?? array(),
                    $this->thesaurus[$dir][$language] ?? array()
                );
                if (count($strings) > count($common_strings)) {
                    $success = !$strict;
                    foreach (
                        array_diff_key(
                            $this->thesaurus[$dir][$language] ?? array(),
                            $this->thesaurus[$dir][self::DEFAULT_LANGUAGE] ?? array()
                        )
                        as $key => $value
                    ) {
                        ANSIColorWriter::printf("Warning: missing key in strings file\n", 'yellow');
                        ANSIColorWriter::printf("------------------------------------\n", 'bright-black');
                        ANSIColorWriter::printf(
                            "Language: %s\n",
                            'bright-black',
                            ANSIColorWriter::colorize(self::DEFAULT_LANGUAGE, 'white')
                        );
                        ANSIColorWriter::printf(
                            "    File: %s\n",
                            'bright-black',
                            ANSIColorWriter::colorize(
                                sprintf('%s/localizable-%s.strings', $dir, self::DEFAULT_LANGUAGE),
                                'white'
                            )
                        );
                        ANSIColorWriter::printf(
                            "     Key: %s\n\n",
                            'bright-black',
                            ANSIColorWriter::colorize($key, 'white')
                        );
                    }
                } elseif (count($this->thesaurus[$dir][self::DEFAULT_LANGUAGE]) > count($common_strings)) {
                    $success = !$strict;
                    foreach (
                        array_diff_key(
                            $this->thesaurus[$dir][self::DEFAULT_LANGUAGE],
                            $this->thesaurus[$dir][$language]
                        )
                        as $key => $value
                    ) {
                        ANSIColorWriter::printf("Warning: missing key in strings file\n", 'yellow');
                        ANSIColorWriter::printf("------------------------------------\n", 'bright-black');
                        ANSIColorWriter::printf(
                            "Language: %s\n",
                            'bright-black',
                            ANSIColorWriter::colorize($language, 'white')
                        );
                        ANSIColorWriter::printf(
                            "    File: %s\n",
                            'bright-black',
                            ANSIColorWriter::colorize(sprintf('%s/localizable-%s.strings', $dir, $language), 'white')
                        );
                        ANSIColorWriter::printf(
                            "     Key: %s\n\n",
                            'bright-black',
                            ANSIColorWriter::colorize($key, 'white')
                        );
                    }
                }
            }
        }

        return $success;
    }

    protected function get_key_prefix(string $key)
    {
        $prefix = implode('-', array_slice(explode('-', $key), 0, 2));
        return $prefix;
    }

    protected function format_file($dir, $filename, $write = false)
    {
        $success = true;

        $path = $dir . '/' . $filename;

        $handle = fopen($path, 'r');
        $contents = fread($handle, filesize($path));
        fclose($handle);

        try {
            eval("\$strings = $contents;");

            $keys = array_keys($strings);
            sort($keys);

            $sorted_strings = '';
            $last_prefix = null;
            foreach ($keys as $key) {
                $key_prefix = $this->get_key_prefix($key);
                if (!is_null($last_prefix) && $key_prefix != $last_prefix) {
                    $sorted_strings .= "\n";
                }
                $sorted_strings .= sprintf(
                    "    %s => %s,\n",
                    var_export($key, true),
                    $this->export_string($strings[$key])
                );
                $last_prefix = $key_prefix;
            }

            if ($write) {
                $template = <<<EOT
array(
%s);

EOT;

                file_put_contents($path, sprintf($template, $sorted_strings));
            }
        } catch (Throwable $t) {
            $success = false;
            printf(
                "[%s] Malformed strings file: %s\n\t%s\n\n",
                ANSIColorWriter::colorize('Error', 'red'),
                $path,
                $t->getMessage()
            );
            $lines = explode("\n", $contents);
            foreach (range($t->getLine() - 2, $t->getLine() + 2) as $i) {
                if ($i === $t->getLine()) {
                    ANSIColorWriter::printf("%4d | %s\n", 'red', $i, $lines[$i - 1]);
                } else {
                    printf("%4d | %s\n", $i, $lines[$i - 1]);
                }
            }
            printf("\n");
        } finally {
            return $success;
        }
    }

    protected function check_file($dir, $filename)
    {
        $success = true;

        $path = $dir . '/' . $filename;

        $handle = fopen($path, 'r');
        $contents = fread($handle, filesize($path));
        fclose($handle);

        preg_match('/-([a-z]{2})\.strings$/', $filename, $matches);
        list(, $language) = $matches;

        try {
            eval("\$strings = $contents;");

            foreach ($strings as $key => $value) {
                $this->set_string($dir, $language, $key, $value);
            }
        } catch (Throwable $t) {
            $success = false;
            printf(
                "[%s] Malformed strings file: %s\n\t%s\n\n",
                ANSIColorWriter::colorize('Error', 'red'),
                $path,
                $t->getMessage()
            );
            $lines = explode("\n", $contents);
            foreach (range($t->getLine() - 2, $t->getLine() + 2) as $i) {
                if ($i === $t->getLine()) {
                    ANSIColorWriter::printf("%4d | %s\n", 'red', $i, $lines[$i - 1]);
                } else {
                    printf("%4d | %s\n", $i, $lines[$i - 1]);
                }
            }
            printf("\n");
        } finally {
            return $success;
        }
    }

    protected function set_string($dir, $language, $key, $value)
    {
        $dir = $this->get_string_file($dir);
        if (!isset($this->thesaurus[$dir])) {
            $this->thesaurus[$dir] = array();
        }
        if (!isset($this->thesaurus[$dir][$language])) {
            $this->thesaurus[$dir][$language] = array();
        }
        $this->thesaurus[$dir][$language][$key] = $value;
    }

    protected function get_string_file($dir)
    {
        // This path is relative to the Composer bin directory if available
        $base_dir = ($GLOBALS['_composer_bin_dir'] ?? __DIR__ . '/../vendor/bin') . self::DEFAULT_BASE_DIR;
        if (strpos($dir, $base_dir) === 0) {
            $dir = substr($dir, strlen($base_dir) + 1) ?: '';
        }
        return $dir;
    }
}

$cli = new EmerailsLocalize();
$cli->run();


?>
